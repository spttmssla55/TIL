1장 알고리즘 개요
1. 알고리즘
정의 : 문제를 해결하기 위한 단계적인 절차

특징
	1. 정확성 : 올바른 답
	2. 수행성 : 알고리즘의 각 단계
	3. 유한성 : 일정한 시간 내에 종료
	4. 효율성 : 효율적일수록 가치UP

단계를 표현하는 방법
	1. 일상 생활에서 사용하는 자연어를 사용
	2. 순서도		//		플로 차트
	3. 의사 코드 (알고리즘은 의사코드로 표현)
	4. 컴퓨터 프로그래밍 언어

2. 탐색 알고리즘 
순차탐색 : 한장씩 비교하며 찾음
이진탐색 : 오름차순으로 된 데이터를 반으로 나누고 나누어진 반을 또 나누고 반복
그리드 알고리즘 : 가장 좋은 선택지를 고름 ( 예 : 거스름돈 계산 문제 -> 최소한의 동전을 받음 )
한붓그리기 : 사이클이 존재하는 경로 탐색

3. 가짜 동전
반으로 나눠 가짜 동전 더미를 찾고 거기서 반 나누기 반복

4. 최초의 알고리즘
유클리드 최대공약수 알고리즘 : 2개의 자연수의 최대공약수는 큰 수에서 작은 수를 뺀 수와 작은 수와의 최대공약수와 같다


5. 효율성 표현
1. 시간복잡도
- 알고리즘 수행 시간

2. 공간 복잡도
- 수행하는 동안 사용되는 메모리 공간의 크기

6. 복잡도 표현 방법
1. 최악 경우 분석
- 어떤 경우에도 이만큼의 성능은 보장
2. 평균 경우 분석
- 대체적으로 알고리즘이 내는 성능
3. 최선 경우 분석
- 운이 좋다면, 이 정도의 성능을 내는 것이 가능 (도움 안됨)


7. 점근 표기법
- 알고리즘의 수행시간을 대략적으로 나타내는 방법
1. O-표기 : 최악의 경우의 알고리즘 수행시간을 표현 (가장 많이 사용)
2. 오메가-표기 : 수행해야 하는 최소한의 수행시간
3. 데타-표기 : O 표기법(상한) 과 오메가-표기(하한)을 모두 만족시키는 증가 함수

--------------------------
2장 자료구조와 알고리즘
1. 자료구조
정의 : 데이처 처리를 위해 메모리에 저장 (데이터 값의 모임, 데이터 간의 관계를 의미)

필요성:
	1. 메모리 효율적 사용
	2. 해결 방법에 따라 선택이 달라짐
	3. 설계 시 고려해야함
	4. 성능에 직접적인 영향

2. 정보와 데이터
정보 정의 : 어떤 목적에 맞게 정리된 자료
데이터 정의 : 컴퓨터의 저장 방식에 맞추어 변환된 자료

3. 컴퓨터 저장장치
- Main Memory, Memory, RAM, 메모리, 주기억장치)

4. 선형, 비선형
선형 자료구조 : 순서가 정해져 있는 자료구조
	1. 배열			-> 기본 자료구조
	2, 연결 리스트		-> 기본 자료구조
	3. 스택			-> 특정한 규칙
	4. 큐				-> 특정한 규칙

비선형 자료구조 : 순서가 정해져 있지 않는 자료구조
	1. 트리			-> 특정한 규칙
	2. 그래프			-> 특정한 규칙



5. 연결 리스트
링크드 리스트
노드(데이터, 포인터)가 한 줄로 연결되어 있는 방식 
개념이 복잡, 구현 어려움
메모리 사용 효율성 높음
데이터 접근 느림

-------------------------
스택 구조
- LIFO
- 배열 자료구조 -> 스택의 크기를 미리 정해놓고 사용
- 연결 리스트 자료구조 -> 스택의 크기가 한정되지 않음
print 하면서 "(" 열때 스택은 PUSH() 한다, ")" 할떄 POP()한다. 스택에 데이터가 없으면 괄요의 개수가 맞는 것
A*B-C/D 연산 -> (A * B) → AB* -> (C / D) → CD/ -> (AB*) - (CD/) → AB*CD/-

Stack에 값 추가 
def push(item):
  global top
  stack.append(item):
  top += 1

  값 뻄
  def pop():
    global top
    if len(stack) != 0:
      item = stack.pop(top)
      top -= 1
      return item


싱글링크드리스트
singlyLinkedList
-> 자료구조중 하나로 데이터를 일렬로 연결된 노드 들로 구성하는 방식
- (배열과 비슷하게 보일 수 있지만 작동 방식이 다름)
- 여러 개의 노드로 구성, 보통 2가지 정보를 가지고 있음 [Data | Next] -> [Data | Next] -> [Data | Next] -> null //  첫번째 노드를 head, 마지막 노드의 Next는 null

 **중요**
 - self: 클래스의 인스턴스(객체)를 참조하는 변수 // 클래스가 생성된 객체를 가리킨다. 따라서 객체 속성에 접근할 떄 self. 이라는 걸 하는거임

큐 
- FIFO

-> 추가
def enqueue(data):
  queue.append(data) 

-> 제거
def dequeue():
  dequeue_object = None
  if len(queue) == 0:
    print(" 큐 안에 없음")
  else:
    dequeue_object = queue[0]
    queue.remove(queue[0])

    return dequeue_object


그래프
- 정점(vertex // 노드)과 간선(edge // 정점을 연결하는 선)으로 이루어진 자료구조
방향 그래프 : A --> B   이떄 A는 Tail, B는 Head       //          무 방향 그래프 : A -- B         

오일러 증명 -> 한붓 그리기 : 연결 되어 있는 선이 홀수 개인 점이 없거나 두 개만 있는 도형 // 따라서 다리문제는 한붓 그리기 불가능
오일러 경로 : 모든 간선을 한 번씩 방문하는 유한 그래프

인접 : 간선으로 연결되어 있는 두 정점, 이웃 관계 (예: (A. B) / (B, C) / (C, D)
경로 : 간선을 통해 서로 이웃된 각 정점들로 그래프 안에서 형성된 길을 말함. (예: A -- B -- C -- D     // 정점 A에서 D까지는 A,B,C,D 한개의 경로를 이루고 있다.
차수 : 정점에 속한 간선들의 개수
연결 : 무 방향 그래프 내에서 두 정점 사이의 경로가 있으면 연결 되었다고 함 // 정점이 전부 연결되어 있으면 그래프가 연결되었다고 함
사이클 : 어느 경로가 정점 하나를 두 번 이상 거치도록 되어있는 경로, 처음과 마지막 정점이 같은 "단순 경로" : 중간에 정점 중복 없이 처음 정점으로 되돌아오는 경로


인접 리스트
- 각 정점이 연결된 다른 정점들을 리스트(또는 배열)로 저장하는 구조
- 장점 : 적은 메모리 공간 요구, 단점: 인접 행렬보다 접근이 느림
A --- B
|     |
C --- D

표현 방법 
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}

그래프 표현 - 배열
- 2차원 배열 자료구조 사용
- 장점: 인접 리스트 보다 접근 빠름, 단점: 많은 메모리 공간 요구
- 정점 사이에 간선이 있다면 열의 원소 1로 표현, 아니면 0


트리
- 노드와 간선으로 구성
- 그래프의 일종으로 여러 노드가 한 노드를 카리킬 수 없는 구조

B 트리
- 자식 노드가 2개 이상
이진 트리
- 각 노드가 최대 2개의 자식 노드를 가질 수 있다.
완전 이진 트리
- 모든 레벨이 꽉 찬 이진 트리
균형 이진 트리
- 왼쪽과 으론쪽의 서브트리의 높이 차이가 1 이하여야 가능

Level 0 -> 루트(root)           Level1 -> 가지(branch)                Level2 -> 형제(sibling) // 가지 안에 있음         Level3 -> 잎(leaf)


표현
인접 리스트
- 자식을 자리키는 포인터  // 1차원 배열 -> 자신의 부모 노드만 저장              // 2차원 배열 -> A[i][0] : 왼쪽 자식 노드 , A[i][1] : 오른쪽 자식 노드

깊이 우선 순회 (DSF)
- 시작 노드를 정하고 방문하지 않은 노드가 존재할 때까지 방문
- 한 방향을 정해서 마지막 노드까지 방문 // 종료 조건 시작 정점까지 와야함
- 스택 

너비 우선 순회 (BSF)
- 시작 노드를 정하고 인접한 노드를 모두 방문
- 큐

6. 링크드 큐
#### 노드 선언
```dart
  class Node:
        def __init__(self, item, link):
            self.item = item
            self.next = link
```

큐
정의: 삽입과 삭제 FIFO로 이루어짐
너비우선탐색에서 자주 사용됨

데크
정의 : 양쪽 끝에서 삽입과 삭제를 허용
큐와 스택 혼합










    
