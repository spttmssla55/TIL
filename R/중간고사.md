스택 구조
- LIFO
- 배열 자료구조 -> 스택의 크기를 미리 정해놓고 사용
- 연결 리스트 자료구조 -> 스택의 크기가 한정되지 않음
print 하면서 "(" 열때 스택은 PUSH() 한다, ")" 할떄 POP()한다. 스택에 데이터가 없으면 괄요의 개수가 맞는 것
A*B-C/D 연산 -> (A * B) → AB* -> (C / D) → CD/ -> (AB*) - (CD/) → AB*CD/-

Stack에 값 추가 
def push(item):
  global top
  stack.append(item):
  top += 1

  값 뻄
  def pop():
    global top
    if len(stack) != 0:
      item = stack.pop(top)
      top -= 1
      return item


싱글링크드리스트
singlyLinkedList
-> 자료구조중 하나로 데이터를 일렬로 연결된 노드 들로 구성하는 방식
- (배열과 비슷하게 보일 수 있지만 작동 방식이 다름)
- 여러 개의 노드로 구성, 보통 2가지 정보를 가지고 있음 [Data | Next] -> [Data | Next] -> [Data | Next] -> null //  첫번째 노드를 head, 마지막 노드의 Next는 null

 **중요**
 - self: 클래스의 인스턴스(객체)를 참조하는 변수 // 클래스가 생성된 객체를 가리킨다. 따라서 객체 속성에 접근할 떄 self. 이라는 걸 하는거임

큐 
- FIFO

-> 추가
def enqueue(data):
  queue.append(data) 

-> 제거
def dequeue():
  dequeue_object = None
  if len(queue) == 0:
    print(" 큐 안에 없음")
  else:
    dequeue_object = queue[0]
    queue.remove(queue[0])

    return dequeue_object


그래프
- 정점(vertex // 노드)과 간선(edge // 정점을 연결하는 선)으로 이루어진 자료구조
방향 그래프 : A --> B   이떄 A는 Tail, B는 Head       //          무 방향 그래프 : A -- B         

오일러 증명 -> 한붓 그리기 : 연결 되어 있는 선이 홀수 개인 점이 없거나 두 개만 있는 도형 // 따라서 다리문제는 한붓 그리기 불가능
오일러 경로 : 모든 간선을 한 번씩 방문하는 유한 그래프

인접 : 간선으로 연결되어 있는 두 정점, 이웃 관계 (예: (A. B) / (B, C) / (C, D)
경로 : 간선을 통해 서로 이웃된 각 정점들로 그래프 안에서 형성된 길을 말함. (예: A -- B -- C -- D     // 정점 A에서 D까지는 A,B,C,D 한개의 경로를 이루고 있다.
차수 : 정점에 속한 간선들의 개수
연결 : 무 방향 그래프 내에서 두 정점 사이의 경로가 있으면 연결 되었다고 함 // 정점이 전부 연결되어 있으면 그래프가 연결되었다고 함
사이클 : 어느 경로가 정점 하나를 두 번 이상 거치도록 되어있는 경로, 처음과 마지막 정점이 같은 "단순 경로" : 중간에 정점 중복 없이 처음 정점으로 되돌아오는 경로


인접 리스트
- 각 정점이 연결된 다른 정점들을 리스트(또는 배열)로 저장하는 구조
- 장점 : 적은 메모리 공간 요구, 단점: 인접 행렬보다 접근이 느림
A --- B
|     |
C --- D

표현 방법 
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}

그래프 표현 - 배열
- 2차원 배열 자료구조 사용
- 장점: 인접 리스트 보다 접근 빠름, 단점: 많은 메모리 공간 요구
- 정점 사이에 간선이 있다면 열의 원소 1로 표현, 아니면 0


트리
- 노드와 간선으로 구성
- 그래프의 일종으로 여러 노드가 한 노드를 카리킬 수 없는 구조

B 트리
- 자식 노드가 2개 이상
이진 트리
- 각 노드가 최대 2개의 자식 노드를 가질 수 있다.
완전 이진 트리
- 모든 레벨이 꽉 찬 이진 트리
균형 이진 트리
- 왼쪽과 으론쪽의 서브트리의 높이 차이가 1 이하여야 가능

Level 0 -> 루트(root)           Level1 -> 가지(branch)                Level2 -> 형제(sibling) // 가지 안에 있음         Level3 -> 잎(leaf)


표현
인접 리스트
- 자식을 자리키는 포인터  // 1차원 배열 -> 자신의 부모 노드만 저장              // 2차원 배열 -> A[i][0] : 왼쪽 자식 노드 , A[i][1] : 오른쪽 자식 노드























    
