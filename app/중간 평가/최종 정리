
0장 플러터 개발 환경 준비하기 : 2문항
앱 개발 방식
- 네이티브 방식 : IOS나 안드로이드 같은 플랫폼 자체에서 제공
- 하이브리드 방식 : 웹 사이트로 만든 앱 // 앱 처럼 보이지만 웹 사이트가 들어가 있는 것
- 크로스 플랫폼 방식 : 안드로이드나 ios 앱을 한 번에 만들 수 있음

플러터 특징
-  구글이 만들었고 크로스 플랫폼 방식을 사용
- 진입 장법 낮음, 예쁜 UI, 높은 네이티브 성능, 개발도구 지원

1장 생애 첫 모바일 앱 생성하기
환경 구성 검사
- 앱 생성하려면 먼저 "환경 구성 검사"를 해야하는데 flutter가 제대로 설치 됐는지 확인하는 방법은 많다
1.  flutter doctor를 터미널에 작성,  // 2. flutter_app > test > pubspec.yaml 에 들어가면 왼쪽 위에 flutter doctor 클릭,  //  flutter sdk 환경변수에 추가 안해도 됨. // 저 자세한 결과를 알고 싶다면 flutter doctor --verbose

2장 다트 문법 : 10문항
변수타입 : 1. int: 정수  // 2. double : 실수   // 3. String : 문자열   // 4. bool : 참 또는 거짓

final, const : 변수 앞에 작성하면 변수 값을 수정할 수 없음 (초기값에서 변경 불가)

타입검사 : name is String -> 이 코드에서 is는 name이 문자열 타입이면 true를 반환 is!는 String이 아니면 true

형변환 : 더 상위 개념으로 변환 가능 int -> num // dynamic 은 모든 데이터 타입 허용

익명함수 : 함수를 일회용으로 사용할 떄 사용 // ([인수명]) { [동작 또는 반환값]; }

람다식 : 간단한 코드를 작성할 때 사용 // ([인수명]) =>{ [동작 또는 반환값]; }

선택 매개변수 : 함수를 호출할 떄, 인자를 선택적으로 넘길 수 있는 기능 , {}로 묶어서 사용 // 기본값을 넣을 수 있음

클래스 정의  : 변수와 함수를 가진 객체를 만들기 위한 설계도

상속 vs 인터페이스 : 상속은 코드 재사용성, 계층 구조의 장점 // 강한 결합, 유연성 부족 단점
 			     인터페이스 : 약한 결합, 유연성, 다중 구현의 장점 // 코드 재사용성 부족, 구현의 번거로움의 단점

List, Map, Set 표기법 :
		list : 순서가 있는 연속된 자료 // 명시적 타입 선언 -> list<String>item = ['짜장', '라면'] // 타입 추론 -> var items = ['짜장', '라면']
map : 키와 값으로 쌍 지어진 형태의 자료 구조를 표현 // var cityMap = {'한국': '서울', '일본': '도쿄'}
set : 중복되지 않는 집합을 표현 // list 형식으로 구현 , 추가 -> 변수명.add('안양') // 삭제 add대신 remove

함수형 프로그래밍 특징
일급객체 : 함수나 객체가 일반적인 값처럼 취급, 변수에 할당 가능, 인자로 전달 가능, 반환값으로 사용 가능
	       1. 고차 함수 지원, 2. 유연한 코드 작성, 3. 콜백 처리
forEach : 요소에 대해 주어진 함수를 한 번씩 실행함
where : 특정 조건을 만족하는 요소들만 골라내서 새로운 이터러블로 만들어 주는 메서드
map : 키 - 값 쌍으로 데이터를 저장하고 빠르게 검색함

컬렉션 if : 조건에 따라 컬렉션을 추가 // 배열 안에 if를  사용 할 수 있음
컬렉션 for : 반복문을 사용하여 요소를 생성

3장 프로젝트 구조와 앱 구조
pubspec.yaml 관련 설명 : 다트 / 플러터의 설정 파일, 앱의 메타 정보, 의존성 관리 등
					외부 라이브러리를 추가하거나 관리, 버진, assets 파일들을 설정 

StatelessWidget : 한 번 생생된 후에는 그 값을 변경할 수 없음 // 정적
StatefulWidget : 위젯이 재구성될 떄마다 상태가 변경될 수 있음 // 동적

4장 기본 위젯I : 
화면 배치에 쓰는 위젯 :
Row  : 자식 위젯들을 수평 방향으로 배치
Column : 자식 위젯들을 수직 방향으로 배치
ListView : 위에서 아래로 쭉 나열할 수 있게 해주는 리스트 박스 			// 예) 책장
ListTile : ListView안에 들어가는 한 줄짜리 아이템					// 예) 책장에 꽃힌 한 권의 책
GridView : 화면에 가로와 세로를 격자처럼 나열해주는 위젯
PageView : 페이지를 좌우 (또는 위 아래)로 화면을 넘기는 위젯
AppBar : 앱 화면 맨 위에 있는 바 (제목 표시줄)				// 앱 이름, 아이콘, 메뉴 버튼 등이 들어감
TabBar : 여러 개의 탭 (메뉴 버튼)을 나열한 바				// 사용자가 텝을 눌러서 화면을 바꿀 수 있게 함
Tab : TabBar 안에 들어가는 각각의 탭 항목 (한칸)			// 글자나 아이콘으로 탭 하나를 나타냄
TabBarView : 각 탭을 눌렀을 때 보여주는 실제 화면			// 예) "홈" 탭 -> 홈화면, "뉴스" 탭 -> 뉴스 화면 등

위치, 정렬, 크기를 위한 위젯
Center : 자식 위젯을 부모 위젯의 중앙에 배치
SizedBox : 특정 너비와 높이를 갖는 빈 공간을 만들거나, 자식 위젯의 크기를 제한 하는 위젯
Padding : 바깥에 공간을 만들어 줌
Align : 부모 기준으로 위치 정렬
Expended : 자식 위젯의 크기를 최대한으로 확장 시켜주는 위젯
Card : 카드 처럼 테두리, 그림자로 입체감 있게 만들어주는 상자 박스

버튼 등 위젯 :
ElevatedButton : 입체감이 있는 버튼
TextButton : 최소한의 스타일을 가진 텍스트 레이블 형태의 버튼
IconButton : 아이콘을 클릭할 수 있게 해주는 버튼
FloatingActionButon : 입체감이 있는 둥근 버튼

5장  기본 위젯
Icon : 아이콘 등
Progress : 로딩 중이거나 오래 걸리는 작업들을 할 때 진행 중임을 보여주는 용도
CircleAvatar : 동그란 모양 안에 이미지나 글자를 넣는 위젯 			// 예) 프로필 사진 만들 때 가장 많이 사용
Text : 글자를 넣을 수 있게 하는 용도

입력 관련
TextField : 사용자가 글자를 입력할 수 있는 칸 			// InputDecoration를 통해 힌트로 보여지게 할 수 있음
Checkbox: 여러 개의 네모 박스를 체크 할 수 있음
Switch : Wi-Fi 를 키는 스위치 처럼 ON/OFF 할 수 있는 토글 형태
Radio : 여러 옵션 중 하나만 선택 할 수 있도록 그룹화되어 사용
RadioListTile : ListTile과 Radio 버튼을 결합, 목록 형태로 단일 선택 옵션을 제공
DropdownButton : 미리 정의된 여러 항목 중에서 하나의 값을 선택할 수 있도록 하는 위젯

다이얼로그 등 위젯
AlertDialong : 팝업창
DatePicker : 달력 인터페이스를 통해 특정 날짜를 선택할 수 있도록 제공
TimePicker : 시계 인터페이스를 통해 특정 시간을 선택할 수 있도록 제공

이벤트
GestureDetector : 다양한 터치 제스터를 감지하여 특정 동작을 수행 // 그냥 터치 감지만 하면 되는 경우
InkWell : 탭과 같은 간단한 터치에 시각적인 피드백 효과를 제공      // 시각적 반응, 카드,이미지 등을 버튼처럼 만듦

애니매이션
Hero : 화면 전환 시, 위젯이 애니메이션 효과를 가지며 자연스럽게 이동하게 하는 위젯
AnimatedContainer : 크기, 색상, 여백 등과 같은 속성이 변할 때 애니메이션 효과를 추가해주는 위젯
SliverAppBar : 스크롤 시 크기가 변경됨
SliverFillRemaining : 스크롤 뷰에서 남은 공간을 채우는 용도
SliverList : 스크롤 가능한 목록을 효율적으로 구성함

쿠퍼티노 디자인
기본 UI : ios 다자인 스타일을 따르는 기본적인 UI위젯들의 모음
CupertinoAlertDialog : IOS 스타일 규칙에 맞춰 알림 대화 상자를 표시
CupertinoPicker : IOS 스타일의 룰렛 형태의 선택 UI로, 날짜, 시간, 또는 사용자 정의 목록에서 항목을 선택
 
6장 내비게이션

내비게이션의 동작성
정의 : 화면 간의 이동하고 되돌아올 수 있도록 도와주는 기능
동작 구조 : 스택 자료구조 기반, push와 pop 사용, statelesswidget 사용

push / pop 사용법
push : Navigator.push() 사용, MaterialPageRoute로 이동할 위젯을 지정
pop : Navigator.pop() 사용, 두 번쨰 인수로 데이터를 반환할 수도 있음

routes를 이용한 방법
- 사용할 화면 목록을 미리 정해놓는 것	// 화면마다 이름(경로)를 붙여서 쉽게 이동 가능
MaterialApp 안에 routes를 정의 해야 Scaffold 안에서 설정한 이름을 사용 할 수 있음
Navigator.pushNamed(context, '/second'); 이 방식 사용
		장점 : 코드 깔끔, 화면 관리 편함, 앱 커질수록 이동 흐름 파악 쉬움


8장 플러터 2변경점
1. 웹 지원 추가 : 원래는 앱만 가능했는데 웹도 가능해짐	
2. 데스크톱 앱 정식 지원 : 각 운영체제의 UI와 완벽하게 통합 (윈도우, 맥, 리눅스용 앱도 가능)
3. 사운드 널 안전성 도입 : 컴파일 할 때 Null 값이 있는지 미리 확인 해줌, 앱 안전성 향상
4. 플랫폼 정응형 UI 구성 지원 : flutter_platform_widgets 패키지를 통해 ios / android 다지인 자동 구분 및 적용
5. DevTools 기능 강화 : 성능 분석 메모리 사용, 위젯 구조 시각화 등 개발 편의 도구 강화 // Hot reload와 결합하여 개발 속도 향상

널 안전한 코드

? -> Null 허용 (타입 앞에 적어야 함 )
?. -> 값이 Null이면 오류가 아니라 Null을 리턴 함
?? -> 값이 있으면 원래 값을 출력하고 값이 없으면 오른쪽 값을 출력
! -> 강제 언래핑: 이 값은 절대로 null이 아니니 null 체크 없이 사용 // 값이 Null이라면 앱이 강제 종료 됨
코드 예) 
String? nickname = '길동이';
print(nickname!.length); // 안전하게 사용 가능





 
