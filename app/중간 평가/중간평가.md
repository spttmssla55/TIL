# Flutter 정리

## 0장)	### 네이티브 방식  
- 안드로이드나 iOS 같은 플랫폼 자체에서 제공  

### 하이브리드 방식  
- 앱으로 만들고 네이티브 방식으로 만듬  
- 예) VS Code에서 Flutter 가져와서 만들기 💻

### 크로스 플랫폼 방식  
- 한 번 구현하여 안드로이드와 iOS 등 각 플랫폼용 앱을 만듬  
- 빌드할 때 네이티브 코드로 변환되기 때문에 네이티브 방식으로 개발했을 때와 거의 같은 성능 보장  
- 생산성과 품질을 고려했을 때 선호하는 방식 🚀

### Flutter 형식
- 낮은 진입장벽 🙌  
- 높은 네이티브 성능 ⚡  
- 훌륭한 개발 도구 지원 🛠️  
- 예쁜 UI ✨  

---

## 1장) 환경 구성 검사
- 터미널에서 Flutter 명령 실행  
- 안드로이드 스튜디오 하단에 있는 'Terminal'을 눌러 `flutter doctor` 명령을 직접 입력  
- 왼쪽 프로젝트 창에서 `flutter_app > test > pubspec.yeml`을 선택하고, 오른쪽 상단에 표시된 4가지 링크 중 'Flutter doctor'를 클릭 → 하단 Flutter 창에서 확인 가능  
- Flutter SDK 환경변수에 추가하지 않아도 작동하여 편리 🙆  
- `flutter doctor --verbose` 옵션이 붙은 명령이 수행되어 좀 더 자세한 결과 줌 🔍  

---

## 2장)

### dort 변수 타입
- `int` : 정수  
- `double` : 실수(소수점)  
- `String` : 문자열  
- `bool` : 참 또는 거짓 값을 갖는 타입 (불리언이라고 불림) 말장난임? 😅  

---

### final, const
- 앞에 쓰면 수정이 안됨 ❌

---

### 타입 검사
- `is` : 같으면 True  
- `is!` : 다르면 True  

---

### 형변환 - (!주의! 강의 중 설명한 것으로 출제 - 힌트 : 상속, LLM을 활용할 것)
- `as` 는 다른 타입끼리 변환이 안되고 더 상위 개념으로 변환 가능 (`as num` 생략 가능)  
- 예) `int` 와 `double`은 모두 `num`을 구현하는 타입이지만 서로는 관계가 없기 때문에 형변환이 불가능  
  하지만 `int`와 `double` 모두 상위 개념인 `num`으로 형변환할 수 있음  
  (`dynamic` = 모든 데이터 타입 허용)

---

### 익명 함수
- 이름 없는 함수(무명함수)

([인수명]) {
  [동작 또는 반환값];
}

 ## 람다식
 ([인수명])=>{[동작 또는 반환값]}

Class 정의
- 컴퓨터 세계에서 객체는 저장 공간에 할당되어 값을 가지거나 식별자에 의해 참조되는 공간
- 변수, 자료구조, 함수 또는 메서드 등이 객체
- 객체를 메모리에 작성하는 것이 인스턴스 화 
- 메모리에 작성된 객체를 인스턴스
- 인스턴스화 하기 위해서는 설계도가 필요 설계도 역할하는것이 class
- Class 안에 속성을 표현하는 것이 프로퍼티
예) 이름과 나이 프로퍼티를 가진 사람을 정의한 Class
```dart
class Person{
 String name;
int age;

void addOneYear() {
	age++
	}
}
	
--생략--
var person = Person();
person.age = 10;
person.addOneYear();
print(parson.age);
```
---
선택 매개변수
- 함수를 정의할 때 필수가 아닌 매개변수를 의미 // @required 어노테이션을 사용하여 반드시 값을 전달 할 수 도 있
- {}로 감싸서 정의 // 함수를 호출할 때 매개변수명: 값 형태로 인수를 전달 // 기본값 지정 가능
```dart
void something({String name, int age = 10}) {}

void main() {
  something(name: '홍길동', age: 10); // name: 홍길동, age: 10
  something(name: '홍길동');       // name: 홍길동, age: 10 (age는 기본값 사용)
  something(age: 10);           // name: null, age: 10 (name은 null 허용)
  something();                   // name: null, age: 10 (name은 null 허용, age는 기본값 사용)
}
```
#### 만약 필수 매개변수와 선택 매개변수를 함께 사용하고 싶다면 앞쪽에 필수 매개변수를 먼저 둔다.
---
## 상속 vs 인터페이스
### 상속
**목적** : 코드 재사용, "is-a" 관계 (예: 강아지는 동물이다)
**특징**
- 부모 클래스의 기능을 물려받고 확정 / 변경
- 단일 상속만 가능
**키워드:: extends**


### 인터페이스
**목적** : 기능 계약 (약속), 다형성 지원 (여러 종류를 같은 방식으로 사용)
**특징**
- 필요한 기능 목록만 정의 (구현은 각 클래스에서)
- 디증 구현 가능
- 인터페이스를 사용할 때 인터페이스를 구현하는 클래스가 해당 인터페이스 자체에 직접적으로 강하게 의존하지 않는다.
**키워드 : implements, obstract class (인터페이스 역할 가능)

**정리**
- **상속**은 **코드 재사용성**과 **계층 구조** 면에서 장점을 가지지만 **강한 결합**과 **유연성 부족**이라는 단점
- **인터페이스는 **약한 결합**과 **유연성, 다중 구현** 면에서는 장점을 가지지만, **코드 재사용성 부족**과 **구현의 번거로움**이라는 단점

---
**List**
- 순서가 있는 연속된 자료를 표현할 때 사용

```dart
List<String>item = ['짜장', '라면', '볶음밥'];		// 명시적 타입 선언
var items = ['짜장', '라면', '볶음밥'];			// 타입 추론

print(items[2]);					// 볶음밥
```
---
**Map**
- 키와 값으로 쌍 지어진 사전 형태의 자료 구조를 표현할 떄 사용 (Dictionary 라고 함)

```dart
var cityMap = {
	'한국': '부산',
	'일본': '도쿄',
	'중국': '북경'
};

cityMap['한국'] = '서울';

print(cityMap.length);			// 3
print(cityMap['중국']);			// 북
print(cityMap['미국']);			// null
print(cityMap['한국']);			// 서울

```
---
**Set**
- 중복되지 않는 집합을 표현할 때 사용

```dart
var citySet = {'서울', '수원', '오산', '부산'};

citySet.add{'안양');		// 추가
citySet.remove('수원');		// 삭제

print(citySet.contains('서울'));	// true
print(citySet.contains('도쿄'));	// false
```
---

함수형 프로그래밍 특징 : 일급객체, forEach, where, map


컬렉션 if 또는 컬렉션 for





2장 다트 문법 : 10문항



3장 프로젝트 구조와 앱 구조 : 2문항
pubspec.yaml 관련 설명 (!주의! LLM을 이용해 상세히 파악할 것!)
샘플 앱의 기본구조에서 출제 (예: StatelessWidget, StatefulWidget 의 기본 구조, 각각의 동작성 차이)


4장 기본 위젯I : 6문항
화면 배치에 쓰는 위젯 : 2문항
위치, 정렬, 크기를 위한 위젯 : 2문항
버틍 등 위젯 : 2문항


5장  기본 위젯II: 3문항 5문항
입력 관련 : 1문항
다이얼로그 등 위젯 : 1문항
이벤트 : 1문항
애니매이션 : 1문항
쿠퍼티노 디자인 : 1문항


6장 내비게이션 : 3문항
내비게이션의 동작성 : 1문항
push / pop 사용법 : 1문항
routes를 이용한 방법 : 1문항 (!주의! 강의시 설명한 내용도 포함됨, LLM을 활용할 것)


7장 복잡한 UI 작성 : 2문항
생산성을 높여주는 단축키 : 1문항
carousel_slider 의존성 추가 : 1문항


8장 플러터 2변경점 : 1문항
널 안전한 코드 : 1문항 (!주의! flutter 3기준으로 널에 안전한 코드를 LLM을 활용해서 숙지할 것!)











